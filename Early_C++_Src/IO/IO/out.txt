形成矩阵方式：linspace(a,b,c)从a到b中均匀抽取c个数（默认c为100）
logspace（a，b，c）从10的a次幂到10的b次幂中按对数均匀抽取c个数（默认c为50）
zeros（m，n）产生一个m*n的0矩阵
ones（m，n）产生一个m*n的所有元素均为1的矩阵
randn（m，n）随机产生一个范围在（0.0，1.0）之间的m*n矩阵
magic(N)产生一个N阶魔方矩阵（行列对角线元素和相等）
eye（m，n）产生一个m*n阶单位阵，当m！=n时，则有全为0的行或列
如果你输入的向量已经超过已知矩阵的维数，则出错；如果你给一个超过已知矩阵维数的向量赋值，则原矩阵增加到该维数并赋值，其余元素补0
矩阵元素表示方法：单下标就意味着要把矩阵所有元素按照
列
的次序从左到右一次排开查看
全下标取找到行和列,交叉处就是子矩阵：1.a（[1
3];[2
3])
取行数1、3，取列2、3交叉形成子矩阵
2.a（1:3，2:3）取1~3行、2~3列交叉形成子矩阵（个人觉得“：”这个东西可以理解为“~”）
3.a(:,3)
取所有行，列数为3（“：”默认是从1到无穷）
4.a（1:3，end）取行数1~3、列取维数最大值
单下标方式:a（[1
3；2
6]）取下标为1、3、2、6的元素组成新矩阵
逻辑矩阵：通过logical([0
0
0……])来确定是否去该行或者列，再交叉，逻辑矩阵可以由矩阵进行逻辑运算得出
给矩阵赋值:
1.全下标方式:
A(i,j)=B，A与B必须等行等列，例子：a（1:2,1:3)=[1
1
1;1
1
1]
2.单下标方式:
a（a:b）=[a1
a2
a3...]但下标好理解，按照顺序一个一个赋值；
3.全元素赋值：a(:)=b
全元素赋值，两个矩阵的元素总数形同，一一进行赋值
矩阵删除：就是将对应元素赋值为“[
]”空矩阵
生成大矩阵：[a;a]
将矩阵a按列摞起来；[a
a]将矩阵a按行排起来
矩阵的反转：triu(a)产生上三角阵其余元素赋0
tril(a)产生下三角阵其余赋值0
flipud(a)：矩阵沿水平轴上下反转
fliplr（a)：矩阵沿着竖直轴左右反转
flipdim(a,1、2）：沿着固定轴转动，1为按行转动，2为按列转动
rot90（a）：矩阵逆时针旋转
MATLAB中字符占2个字节：可用whos来查看存在的数据类型、所占字节数
length：计算字符串长度（数组用作计算最大维数)
double：查看字符的ASCII码值
char：将ASCII码转换成字符
class/ischar：用来判断是否是字符串，class函数返回char则为字符串，ischar遇到字符返回1
strcmp(x,y):比较两个字符是否相同，返回1则为相同
findstr(x,x1):寻找在某个字符串x中内涵的字符串x1
deblank(a):删除字符串尾部的空格
eval（）:执行字符串中蕴含的操作（个人觉得很神奇的地方)
disp（）是MATLAB中的cout：进行字符输出的函数
inv(a)：求矩阵的逆阵
det(a):求矩阵行列式数值
rank(a)：求矩阵的秩（只是返回秩的数值)
diag(a):求对角阵
./或者.\是指单个对应元素逐个运算
x1^-1是先把矩阵x1转换成其逆阵，在进行指数对应整数的乘方
X'是求矩阵X的逆阵；X.'是对应每个元素进行求共轭
矩阵和数组的数学函数：
abs：求绝对值
sqrt：求平方
real：求复数的实部
imag：求复数虚部
conj：求复数共轭
sin：正弦
cos：余弦
tan：正切
asin：反正弦
acos：反余弦
atan：反正切
atan2：第四象限反正切
sinh:双曲正弦
cosh：双曲余弦
tanh：双曲正切
Rat：有理数近似
Mod：模除取余
round：四舍五入到整数
Fix：向最接近零取整
Floor：向最接近负无穷取整
ceil：
sign：符号函数
rem：求余数留数
exp：自然指数
log：自然对数
log：以10为底数的对数
pow2:2
的幂
bessel：贝塞尔函数
gamma：伽马函数
关系操作符是用来判断的，返回值是真（1）假（0）两个数之一，矩阵之间的判断也是同样的逐个元素进行比较，返回的是一个由真假值组成的矩阵
MATLAB运算优先等级：'（矩阵转置）
^（矩阵幂）和
.'（数组转置）
.^（数组幂）
->
~（逻辑非）->*（乘）
/（左除）
\（右除）和.*（点乘）
.\（点左除）
./（点右除）
->
+
-（加减）
->
:（冒号）
->
<
<=
>
>=
~=
->
&（先决与）
->
||（先决或）
三维的矩阵最好好是建立空间模型去理解，更加形象，在运算复制操作中也会比较清晰易懂！而高于三维的基本是不会用到的！
rand（a，b，c）：可以随机产生三维随机数组，abc当然就是三个维度的大小
cat（维，p1，p2……）：将一系列数组沿着特定的维连接成一个该维数组
repmat（p）\repmat（p，行
列
页……）：按指定的行列数放置模块数生成多维数组；p用来放置模块数组，后面的变量要放在指定的各维
ndims(a):计算数组维数
[m,n……]=size(p):得出各维的大小；p维所要求维数的数组，m是行数，n是列数……
m=size（p，x）：当只有一个输出变量时，x=1返回第一维大小（行数），x=2返回第二维（列数
）……
稀疏矩阵：
sparse（i，j，s，m，n）：直接创建稀疏矩阵：i、j是非0元素的行、列下表；s是非0元素所形成的向量；m，n是s的行列维数，可以省略
sparse（p）：由全元素矩阵p转换维稀疏矩阵
full（p）：将稀疏矩阵转换成全元素矩阵
spdiags（D，d，4,3）：就是个有病的稀疏矩阵建立函数，D的每一列都为对角线向量，d代表D中对角线在稀疏矩阵应该放的位置，4、3是指名要建立稀疏矩阵的全元素矩阵大小
spconvert：在指定的文件中读入稀疏矩阵；首先在默认路径中建立一个dat文件，然后在文件中存入三列数据，然后按照前两列是行、列坐标，第三列是数值；得到
nnz：可返回稀疏矩阵的非零元素个数
nonzeros：返回1个包含所有非零元素的列向量
nzmax：返回最大的非零元素个数
spy:用图像观看稀疏矩阵的非零元素分布情况
计算多项式值：polyval（p1，x）p1是系数数组，x是未知数取值
多项式求根：r=toots（p）：p是多项式，r就是计算的多项式的根，并以向量形式保存
p=poly（r）：与函数roots相反，根据多项式的根计算多项式的系数（还可以计算方阵的特征多项式）
部分分式展开：[r,p,k]=residue(p1,p2)
（p1是分子多项式系数行向量，
p2是分母多项式系数行向量，
r是展开后各分式分子的行向量，
p是展开后分母的零点：x-p[1]
多项式的乘法和除法：乘法：conv（a1，a2）
除法：deconv（a1，a2）（除法时形式：[p1,r]=deconv(a1,a2)p1是商，r是余子项）
多项式的微分：polyder（p1）:p1当然就是多项式各阶系数了
多项式的积分：先求多项式系数长度（length（p1）函数）确定多项式阶数，然后生成阶数矩阵（例如：3
2
1）用p2=[p1./s,0]生成积分后多项式系数矩阵，0是积分后的常数项，默认为0
根据离散数据推算对应多项式函数：polyfit（x，y，n）;x是横坐标，y纵坐标，n要拟合成函数的阶数
插值：interp1（x，y，x1，’插值方法‘）
一维插值：linear为线性插值（默认）
nearest最接近相邻点插值
spline为三次样条插值
cubic三次插值
interp2(x,y,z,xi,yi,'插值法')
二维插值：linear双线性插值（默认）
nearest最接近点插值
cubic三次插值
元胞是一个类似容器的东西，可以装任何东西：celldisp（A）是显示一个元胞里的元素
cellplot（A）是显示一个元胞，以图形的形式（plot类似后面的画函数图象的函数）
[x1，x2，x3...]=deal（A{[2,3,4]})
把元胞A中的下表为2、3、4的元素复制给x1，x2，x3……
结构数组：结构数组结构数组嘛！当然是由结构组成的了，所以可以用ps(1)=struct（
'域名1'
,
'域名1存储的数据'
,
'域名2'
,
'域名2存储的数据'……);来建立结构数组
ps（1）.name='曲线
1'表示结构数组中
1结构中的
name域内
存储了一个'曲线'
没有耐性了座椅直接进入图象了……
x=peaks是生成一个49*49的矩阵；
plot（x）x是矩阵的话会把每一列都画出一条线来，向量的话系统会自动生成一组横坐标进行画图
当x是复数时，会按照实部为横坐标，虚步为纵坐标
plot（x，y）是画关于x、y的图象，x、y可以使数组矩阵
x是向量，y是矩阵，并且x维数和y的行数或者列数相等：横坐标按照x，y的每一行或者每一列分别画一条线（如果是方阵，则按列）
x是矩阵，y是向量：同上
x和y都是矩阵：但是大小必须相等；x的每一列和y的对应列画图像
axis（【0
4
0
2】）把坐标轴范围设置为横坐标0~4，纵坐标为0~2
figure（n）会产生一个名为figure1的窗口，而且不会覆盖之前打开的窗口
subplot（m,n,k）把原始窗口分割成m*n快，取第k块儿为当前图
clf：清除子图
在两个plot之间用hold
on可以保存图象，使得图象可以同时显示
hold
off之后plot将会覆盖之前的图象，运用hold可以在on
off之间切换
http://answers.microsoft.com/zh-hans/ie/forum/ie8-windows_7/win7/78333608-80b1-4de4-b335-493fd1a9bde6
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xC3,0xDF,0xDF,0xC7,0xDF,0xDF,0xDF,
0xFF,0xDB,0xDB,0xDB,0xDB,0xDB,0xC3,0xFF,
0xFF,0xC3,0xBF,0xBF,0xBF,0xBF,0xC3,0xFF,
0xFF,0xDD,0xDB,0xD7,0xCF,0xD7,0xDB,0xDD,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
